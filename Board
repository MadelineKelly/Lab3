/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package lab_3;

/**
 *
 * @author Madeline
 */

import java.util.Stack;

public class Board {
    
    private Spot[][] board;
    private Spot current, nextMove;
    private boolean visited;
    private int size, r0, c0, countMoves, c, r, nextPos;
    private Stack stack;
    
    private static int[][] moves8 = { {+1,-2}, {+2,-1}, {+2,+1}, {+1,+2}, 
        {-1,+2}, {-2,+1}, {-2,-1}, {-1,-2} };
    
    Board(int size)
    {
        this.size = size;
        board = new Spot[size][size];
        
        //fill board with new Spots
        for (int i = 0; i < board.length; i++)
        {
           for(int j = 0; j < board[0].length; j++)
           {
               board[i][j] = new Spot();
           }
        }
        Stack stack = new Stack();
    }
    
    public boolean get(int pos)
    {
        c = getC(pos);
        r = getR(pos);
        visited = board[r][c].getVisited();
        return visited;
    }
    
    public int getC(int pos)
    {
        c = (pos-1)%size;
        return c;
    }
    
    public int getR(int pos)
    {
        r = (pos-1)/size;
        return r;
    }
    
//    public void move(int pos, int count)
//    {
//        count++;
//        c = getC(pos);
//        r = getR(pos);
//        current = board[r][c];
//        current.setVisited(true);
//        stack.push(current);
//        nextPos = getNextPos(pos, current.getCount());
//        move(nextPos, count);
//    }

    public String move(int pos, int count, int cycle) // picks next
    { // possible
        count++;
        while(cycle < 8) // move
        {
            int dc = moves8[cycle][0]; // get move in
            int dr = moves8[cycle][1]; // (x,y) format
            c = getC(pos);
            r = getR(pos);
            current = board[r][c];
            current.visit();
            c = c + dc; // add move to
            r = r + dr; // position
            cycle++; // used this move
            if(c>=0 && c<size && r>=0 && r<size) // on the board?
            { // yes
                if(board[r][c].getVisited()==false) // unoccupied cell?
                { // yes       
                    nextMove = board[r][c];
                    nextMove.visit();
                    String m = Integer.toString(pos) + " " + Integer.toString(nextPos);
                    int nextPos = c + r*size + 1; // (x,y) to j
                    move(nextPos, count, cycle); // found a move
                    countMoves = count;
                    
                    if (countMoves == (size*size))
                    {
                        return m;    
                    }
                }
            } // end if(x>=0...)
        } // end while // no possible move
        cycle = 0; // reset move index
        String m = "Failure";
        return m;
        //return -1; // failure
    } // end getNextPos()
    
    public int getMoves()
    {
        return countMoves;
    }
}   

//Idea: Create a Spot class that keeps track of whether or not the spot has been visited (true/false), and how many times we've been to it.
//If we've only been in this spot once, make the first move of move8. If it's the second time (i.e. we backtracked once because we got stuck), make
//the second move of move8. And so on and so forth.
//If all options have been exhausted for every spot and we have not won yet, then return "Failure."

//Things to do:
//take in starting square and start making moves
//mark as visited (true) when moved to
//put Spot info on a stack
//keep track of number of moves
//pop off stack and mark as false if we must backtrack
//determine whether or not we have failed
//What does last "()" value mean in their output for moving sequence?
//How do we back track when we get stuck? 
//      - Making sure we change the spots we visited back to false
//      - Keeping track of which moves we've already done we've been
//Do we want to use their getNextPos method or our own? //Mix of both
