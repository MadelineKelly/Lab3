/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package lab_3;

/**
 *
 * @author Madeline
 */

import java.util.Stack;

public class Board {
    
    private Spot[][] board;
    private Spot current;
    private boolean visited;
    private int cycle, size, r0, c0, moves, c, r, nextPos;
    private Stack stack;
    
    private static int[][] moves8 = { {+1,-2}, {+2,-1}, {+2,+1}, {+1,+2}, 
        {-1,+2}, {-2,+1}, {-2,-1}, {-1,-2} };
    
    Board(int size)
    {
        this.size = size;
        board = new Spot[size][size];
        
        //fill board with new Spots
        for (int i = 0; i < board.length; i++)
        {
           for(int j = 0; j < board[0].length; j++)
           {
               board[i][j] = new Spot();
           }
        }
        Stack stack = new Stack();
    }
    
    public boolean get(int pos)
    {
        c = getC(pos);
        r = getR(pos);
        visited = board[r][c].getVisited();
        return visited;
    }
    
    public int getC(int pos)
    {
        c = pos%size;
        return c;
    }
    
    public int getR(int pos)
    {
        r = (pos/size) + 1;
        return r;
    }
    
    public void move(int pos)
    {
        c = getC(pos);
        r = getR(pos);
        current = board[r][c];
        current.setVisited(true);
        stack.push(current);
        nextPos = getNextPos(pos, current.getCount());
        move(nextPos);
    }

    public int getNextPos(int pos, int cycle) // picks next
    { // possible
        //while(cycle < 8) // move
        //{
            int dc = moves8[cycle][0]; // get move in
            int dr = moves8[cycle][1]; // (x,y) format
            c = getC(pos);
            r = getR(pos);
            c = c + dc; // add move to
            r = r + dr; // position
            cycle++; // used this move
            if(c>=0 && c<size && r>=0 && r<size) // on the board?
            { // yes
                int nextPos = c + r*size + 1; // (x,y) to j
                if(get(nextPos)==false) // unoccupied cell?
                { // yes
                    return nextPos; // found a move
                }
            } // end if(x>=0...)
        //} // end while // no possible move
        //cycle = 0; // reset move index
        return -1; // failure
    } // end getNextPos()
}   

//Idea: Create a Spot class that keeps track of whether or not the spot has been visited (true/false), and how many times we've been to it.
//If we've only been in this spot once, make the first move of move8. If it's the second time (i.e. we backtracked once because we got stuck), make
//the second move of move8. And so on and so forth.
//If all options have been exhausted for every spot and we have not won yet, then return "Failure."

//Things to do:
//take in starting square and start making moves
//mark as visited (true) when moved to
//put Spot info on a stack
//keep track of number of moves
//pop off stack and mark as false if we must backtrack
//determine whether or not we have failed
//What does last "()" value mean in their output for moving sequence?
//How do we back track when we get stuck? 
//      - Making sure we change the spots we visited back to false
//      - Keeping track of which moves we've already done we've been
//Do we want to use their getNextPos method or our own? //Mix of both
